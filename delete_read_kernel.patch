diff --git a/kernel/nvidia/nv-gpu-numa.c b/kernel/nvidia/nv-gpu-numa.c
index 1463d2dfd5e8..4520beb33f51 100644
--- a/kernel/nvidia/nv-gpu-numa.c
+++ b/kernel/nvidia/nv-gpu-numa.c
@@ -106,34 +106,6 @@ static inline char* mem_state_to_string(mem_state_t state)
 }
 
 // TODO: Bug 1735381: don't open files from within kernel code
-static NV_STATUS bad_idea_read_string_from_file(const char *path_to_file,
-                                                char *read_buffer,
-                                                size_t read_buffer_size)
-{
-    struct file *filp;
-    int read_count;
-
-    filp = filp_open(path_to_file, O_RDONLY, 0);
-    if (IS_ERR(filp)) 
-    {
-        nv_printf(NV_DBG_ERRORS, "filp_open failed\n");
-        return NV_ERR_NO_VALID_PATH;
-    }
-
-    read_count = kernel_read(filp, 0, read_buffer, read_buffer_size - 1);
-
-    filp_close(filp, NULL);
-
-    if (read_count <= 0)
-        return NV_ERR_INVALID_STATE;
-
-    read_buffer[read_count] = '\0';
-
-    // read_count > 0:
-    return NV_OK;
-}
-
-// TODO: Bug 1735381: don't open files from within kernel code
 static NV_STATUS bad_idea_write_string_to_file(const char *path_to_file,
                                                const char *write_buffer,
                                                size_t write_buffer_size)
@@ -163,38 +135,6 @@ static NV_STATUS bad_idea_write_string_to_file(const char *path_to_file,
     return NV_OK;
 }
 
-// Reads a number from a file, and interprets it as a hexadecimal value, even
-// though there is typically not any "0x" prefix.
-static NV_STATUS bad_idea_read_hex_integer_from_file(const char *path_to_file,
-                                                     NvU64 *read_value)
-{
-    NV_STATUS status;
-    char buf[READ_BUFFER_SIZE];
-
-    status = bad_idea_read_string_from_file(path_to_file, buf, sizeof(buf));
-    if (status != NV_OK)
-        return status;
-
-    if (kstrtoull(buf, 16, read_value) != 0)
-    {
-        nv_printf(NV_DBG_ERRORS, "Parsing file failed!\n");
-        return NV_ERR_INVALID_ARGUMENT; 
-    }
-
-    return NV_OK; 
-}
-
-static NV_STATUS read_memblock_size(NvU64 *memblock_size)
-{
-    // TODO: Bug 1735381: don't open files from within kernel code. In this
-    // case, the kernel put the information into sysfs in the first place.
-    // Therefore (unless GPL is a problem?), it seems unnecessary to go all the
-    // way back through a user-space code path (accessing the sysfs pseudo
-    // filesystem), to get that same information.
-
-    return bad_idea_read_hex_integer_from_file(MEMBLK_SIZE_PATH, memblock_size);
-}
-
 // This is a callback for iterate_dir. The callback records the range of memory
 // block IDs assigned to this NUMA node. The return values are Linux kernel
 // errno values, because the caller is Linux's iterate_dir() routine.
@@ -247,22 +187,11 @@ static NV_STATUS change_memblock_state(int numa_node_id, int mem_block_id, mem_s
 {
     NV_STATUS status;
     char numa_file_path[BUF_SIZE];
-    char buf[BUF_SIZE];
-    mem_state_t cur_state;
     const char *cmd;
 
     sprintf(numa_file_path, "%s%d/%s%d/%s", NID_PATH, numa_node_id, MEMBLOCK_PREFIX,
             mem_block_id, MEMBLOCK_STATE_ATTR);
 
-    status = bad_idea_read_string_from_file(numa_file_path, buf, sizeof(buf));
-    if (status != NV_OK)
-        goto done;
-
-    cur_state = !!strstr(buf, STATE_ONLINE) ? MEM_ONLINE : MEM_OFFLINE;
-
-    if (cur_state == new_state)
-        goto done;
-
     switch (new_state) 
     {
         case MEM_ONLINE:
@@ -276,8 +205,6 @@ static NV_STATUS change_memblock_state(int numa_node_id, int mem_block_id, mem_s
     }
 
     status = bad_idea_write_string_to_file(numa_file_path, cmd, strlen(cmd));
-
-done:
     if (status == NV_OK)
         nv_printf(NV_DBG_INFO, "Successfully changed state of %s to %s\n", numa_file_path,
                       mem_state_to_string(new_state));
@@ -467,9 +394,8 @@ NV_STATUS nv_numa_memblock_size
     NvU64 *memblock_size
 )
 {
-    if (read_memblock_size(memblock_size))
-        return NV_ERR_INVALID_STATE;
-    return NV_OK;
+    *memblock_size = 0;
+    return NV_ERR_NOT_SUPPORTED;
 }
 
 
