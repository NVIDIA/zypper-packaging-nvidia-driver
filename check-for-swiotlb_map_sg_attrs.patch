--- a/kernel/conftest.sh
+++ b/kernel/conftest.sh
@@ -267,6 +267,26 @@ 
     fi
 }
 
+export_symbol_present_conftest() {
+    #
+    # Check Module.symvers to see whether the given symbol is present.
+    #
+
+    SYMBOL="$1"
+    TAB='	'
+
+    if grep -e "${TAB}${SYMBOL}${TAB}.*${TAB}EXPORT_SYMBOL.*\$" \
+               "$OUTPUT/Module.symvers" >/dev/null 2>&1; then
+        echo "#define NV_IS_EXPORT_SYMBOL_PRESENT_$SYMBOL 1" |
+            append_conftest "symbols"
+    else
+        # May be a false negative if Module.symvers is absent or incomplete,
+        # or if the Module.symvers format changes.
+        echo "#define NV_IS_EXPORT_SYMBOL_PRESENT_$SYMBOL 0" |
+            append_conftest "symbols"
+    fi
+}
+
 export_symbol_gpl_conftest() {
     #
     # Check Module.symvers to see whether the given symbol is present and its
@@ -3048,6 +3068,10 @@ 
             compile_check_conftest "$CODE" "NV_KREF_HAS_REFCOUNT_OF_TYPE_REFCOUNT_T" "" "types"
         ;;
 
+        is_export_symbol_present_*)
+            export_symbol_present_conftest $(echo $1 | cut -f5- -d_)
+        ;;
+
         is_export_symbol_gpl_*)
             export_symbol_gpl_conftest $(echo $1 | cut -f5- -d_)
         ;;
--- a/kernel/common/inc/nv-linux.h
+++ b/kernel/common/inc/nv-linux.h
@@ -1224,12 +1224,19 @@ 
      */
     #if defined(NV_GET_DMA_OPS_PRESENT)
       #if defined(NV_DMA_MAP_OPS_PRESENT)
-    const struct dma_map_ops *ops = get_dma_ops(&dev->dev);
+    /*
+     * The __attribute__ ((unused)) is necessary because in at least one
+     * case, *none* of the preprocessor branches below are taken, and
+     * so the ops variable ends up never being referred to at all. This can
+     * happen with the (NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_map_sg_attrs == 1)
+     * case.
+     */
+    const struct dma_map_ops *ops __attribute__ ((unused)) = get_dma_ops(&dev->dev);
       #else
-    const struct dma_mapping_ops *ops = get_dma_ops(&dev->dev);
+    const struct dma_mapping_ops *ops __attribute__ ((unused)) = get_dma_ops(&dev->dev);
       #endif
     #else
-    const struct dma_mapping_ops *ops = dma_ops;
+    const struct dma_mapping_ops *ops __attribute__ ((unused)) = dma_ops;
     #endif
     #if defined(NV_DMA_MAP_OPS_PRESENT)
     /*
@@ -1241,9 +1248,27 @@ 
     /* AArch64 exports these symbols directly */
     swiotlb_in_use = ((ops == &noncoherent_swiotlb_dma_ops) ||
                       (ops == &coherent_swiotlb_dma_ops));
-      #else
+      #elif NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_map_sg_attrs != 0
     swiotlb_in_use = (ops->map_sg == swiotlb_map_sg_attrs);
       #endif
+      /*
+       * The "else" case that is not shown
+       * (for NV_IS_EXPORT_SYMBOL_PRESENT_swiotlb_map_sg_attrs == 0) does
+       * nothing, and ends up dropping us out to the last line of this function,
+       * effectively returning false. The nearly-human-readable version of that
+       * case is "struct dma_map_ops is present (NV_DMA_MAP_OPS_PRESENT is
+       * defined) but swiotlb_map_sg_attrs is not present".
+       *
+       * That can happen on kernels that are later than:
+       *
+       * 2017-12-24  4bd89ed39b2ab8dc4ac4b6c59b07d420b0213bec
+       *     ("swiotlb: remove various exports")
+       *
+       * Related to this: as of the above commit, this driver has no way of
+       * detecting whether or not the SWIOTLB is in use. Furthermore, the
+       * driver cannot support DMA remapping. That leads to the following
+       * point: "swiotlb=force" is not supported.
+       */
     #else
     swiotlb_in_use = (ops->map_sg == swiotlb_map_sg);
     #endif
--- a/kernel/nvidia/nvidia.Kbuild
+++ b/kernel/nvidia/nvidia.Kbuild
@@ -153,6 +153,7 @@ 
 NV_CONFTEST_FUNCTION_COMPILE_TESTS += timer_setup
 
 NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_gpl_of_node_to_nid
+NV_CONFTEST_SYMBOL_COMPILE_TESTS += is_export_symbol_present_swiotlb_map_sg_attrs
 
 NV_CONFTEST_TYPE_COMPILE_TESTS += i2c_adapter
 NV_CONFTEST_TYPE_COMPILE_TESTS += pm_message_t
